	--- Чтобы создать проект на ASP.NET Core, выбираем шаблон ASP.NET Core Web App (Model-View-Controller).Нужно 
ОБЯЗАТЕЛЬНО запомнить версию .NET Core, так как в дальнейшем нужно будет устанавливать плагины и фреймворки 
точно с такой же версией. Можно не выбирать никакой аутентификации, позже ее можно будет добавить вручную. 
Выбираем конфигурацию HTTPS. Включаем Razor (если есть). 
	--- Сначала, создаем модель (ПКМ -> New Class с названием модели без каких-либо других слов -> Внутри модели
прописываем свойство (prop + Tab + Tab). Свойство будет представлять из себя столбцы базы данных (Id, Name итд.) ->
Ставим атрбиут [Key] для первичного ключа (ставим перед свойством Id))
	--- После создания модели, ее необходимо добавить в базу данных. Для этого заходим на SQL Server, подключаемся 
к серверу. Затем переходим обратно в код, где нужно будет добавить строку подключения. Каждый раз, когда нужно 
добавлять какую-либо строку подключения, делать это нужно в файле appsettings.json. Создаем строку 
"ConnectionStrings" : {},. В скобках пишем имя подключения, например "DefaultConnection" :. После двоеточия в 
двойных кавычках пишем следующую запись строки подключения: "Server=ИмяСервера;Database=ИмяБД(например, как
название проекта);Trusted_Connection(Доверенное соединение с сервером)=True". Например: "Server=.;Database=Rocky;
Trusted_Connection=True".
	--- Чтобы создать базу данных через Visual Studio (VS) и разместить там модель, нам нужен DbContext, который 
предоставляется Entity Framework. Сначала добавляем в проектновую папку, называем ее Data. Внутри нее добавляем
новый класс и называем его ApplicationDbContext (можно назвать как угодно, главное, чтобы в конце было DbContext).
Делаем наш созданный класс DbContext'ом. Для этого наследуем у класса DbContext (в конце строки с названием класса
пишем : DbContext). Иначально, VS не видит этот класс, поэтому нужно установить Entity Framework Core. Для этого
заходим в Tools -> NuGet Package Manager -> Manage NuGet Packages for Solution. В открывшемся окне заходим на 
вкладку Browse и в поиске пишем текст sqlserver. Прописываем это так как, нам нужна серверная часть фреймоврка
(хотя entity framework core установится автоматически вместе с sql server). Выбираем в найденных 
Microsoft.EntityFrameworkCore.SqlServer, справа отмечаем галочкой наш проект (потому что для него мы хотим 
установить пакет), выбираем ТОЧНО ТАКУЮ ЖЕ версию, как и версия .Net Core в проекте и устанавливаем. Проверить 
установленный пакет можно в Soltion Explorer: Dependencies -> Packages. После установки пакета, можно вернуться 
в ApplicationDbContext.cs, навести на класс DbContext, нажать ctrl + . и выбрать подсказку 
using Microsoft.EntityFrameworkCore. Все заработает. Далее в этом же файле, в теле класса пишем конструкторы 
(ctor + Tab + Tab). В параметры пишем DbContextOptions<ApplicationDbContext> options. Далее в конце строки пишем 
: base(options). 
	--- Теперь, чтобы создать таблицу модели в базе данных, в файле ApplicationDbContext нужно добавить свойство,
отвечающее за размещение модели в базе данных. Пишем prop + Tab + Tab, даем тип свойству DbSet<ИмяМодели> и 
называем таким же именем, как у модели. Всякий раз, при создании новой модели, в этом файле нужно будет добавлять
новое свойство, только менять его название на имя класса. После этого заходим в файл program.cs и в поле с 
контейнерами добавляем строку builder.Services.AddDbContext<ApplicationDbContext>(options => options.UseSqlServer(
builder.Configuration.GetConnectionString("DefaultConnection"))); Это нужно для того, чтобы таблицы моделей
добавлялись в баз данных через VS. Теперь, после окончательной настройки базы данных, всякий раз, когда нужно 
передавать любые изменения в базу данных, необходимо будет создавать миграции. Поэтому, после того, как мы добавили
модель, нужно также добавить миграцию, чтобы отправить ее в базу даннных. Чтобы добавить миграцию, заходим в 
Tools -> NuGet Package Manager -> Package Manager Console. В открывшейся консоли пишем add-migration и через пробел
пишем addИмяМоделиToDatabase и нажимаем Enter. Если после этого действия возникла ошибка, переходим снова в 
Manage NuGet Packages for Solution и пишем в поиске tools. Среди найденных выбираем 
Microsoft.EntityFrameworkCore.Tools. Точно так же выбираем справа на проект и точно такую же версию, затем 
устанавливаем. После этого ошибка должны пропасть. Entity Framework Core добавил папку Migrations, в которой можно
проверить корректность созданной миграции для нужной модели. Теперь остается отправить созданную миграцию в саму
базу данных. Для этого переходим снова в Package Manager Console и пишем update-database. После этого действия
ожидающие миграции будут отправлены в базу данных. В конце можем зайти на Sql Server и проверить, все ли правильно.
Находим, что в нашем базе данных была создана таблица с названием модели.
	--- Теперь добавляем контроллер для нашей модели. Для этого в папке Controllers добавляем Controller ->
MVC Controller - Empty, затем называем этот контроллер, как модель, и в конце обязательно прописываем Controller.
В папке Views -> Shared -> _Layout.cshtml можем добавить либо изменить кнопку для работы с новой моделью. Можно
поменять значение контроллера на наш новый контроллер, а имя action-метода на Index (изначальный, основной метод
контроллера). Однако при нажатии на ссылку ничего не сработает, так как для модели с контроллером необходимо 
добавить представление View.
	--- Чтобы создать представление, переходим в нужный контроллер, нажимаем ПКМ по action-методу и нажимаем 
Add View -> Razor View (БЕЗ EMPTY!!!!!!), ничего не меняем, нажимаем Add. После этого в папке Views будет создана
папка с названием модели, а внутри ее файл Index.cshtml, который и будет представлять из себя frontend-часть 
страницы.
	--- Чтобы извлечь данные из базы данных и вывести их на странице, обращаемся за помощью к Entity Framework и 
ApplicationDbContext. Для этого переходим в нужный контроллер и создаем в начале тела класса приватное свойство типа
ApplicationDbContext, доступное только для чтения (private readonly ApplicationDbContext _db). Называем свойство _db.
Теперь создаем конструктор (ctor + Tab + Tab) и, благодаря внедрению зависимостей, используя недавно добавленный
в program.cs ApplicationDbContext в контейнере, извлекаем информацию из этого контейнера - в параметры конструктора
ссылаемся на класс либо интерфейс, в данном случае это - ApplicationDbContext. Называем этот параметр db. В теле 
конструктора пишем _db = db, то есть присваиваем нашему локальному _db ссылку на объект db, полученный в параметрах
конструктора. Теперь у нас есть объект _db, который имеет доступ к базе данных. Далее, если мы хотим вывести
информацию на экран в качестве списка, здесь же, в конструкторе, в нужном action-методе создаем список типа 
IEnumerable<ОбъектСИменемМодели>. Называем список objList и присваиваем ему объект базы данных, через точку 
обращаемся к его методу, имеющему такое же название, что и модель (благодаря Entity Framework). Теперь у нас есть
объект objList со всей информацией из таблицы базы данных в качестве таблицы. Далее в return View() в скобках
передаем этот объект. Чтобы отобразить для пользователя таблицу со всей полученной из базы данных информацией, 
нужно принять ссылку внутри view Index, переданную только что из контроллера (return View(objList)). Чтобы сообщить
преставлению Index, что нам нужен переданный из его контроллера список с информацией, вверху, в самом начале
View, определяем ссылку на модель с помощью @model IEnumerable<ИмяПроекта.Models.ИмяМодели>. Теперь переданный 
список доступен во View, и внутри этого представления Index мы теперь можем с ним работать и, например, вывести 
список на экран.
	--- При необходимости создания, добавления новой информации через браузер, в нужном контроллере создаем новый
action-метод с названием Create. Внутри метода нам не нужно передавать никакую информацию,поэтому удаляем строку 
IEnumerable<Category> objList = _db.Category. Отделим данный метод комментарием GET - CREATE. После добавления 
метода в контроллере, добавляем представление. В любом представлении вначале должна быть ссылка на модель для этого
представления, и, даже, если мы ничего не передаем в return View(пусто), все равно во View в начале пишем 
@model,как это описано выше (в начале файла @model пишется с маленькой буквы, затем, в дальнейшем коде, когда 
нужно обращаться к переданной и полученной модели, пишем Model. с большой буквы). Добавляем форму уже с методом
POST, так как при нажатии кнопки Create мы отпраляем данные на сервер. Добавляем в качестве атрибута asp-action
со значением "ИмяActionМетода". Это означает, что, когда форма выполняет POST-метод, выполняется поиск action-метода
типа POST с именем Create. Теперь, при нажатии на кнопку Create, должно произойти добавление новой информации в 
базе данных. Для этого в контроллере добавляем еще один метод и отделяем его комментарием POST - CREATE. Перед ним
явно указываем, что это POST-метод путем добавления строки [HttpPost]. В параметры метода передаем ссылку на объект
типа ИмяМодели. Между [HttpPost] и самим методом добавим также аттрибут [ValidateAntiForgeryToken]. Это встроенный
механизм для форм ввода, в котором добавляется специальный токен защиты от взлома, в методе POST происходит 
проверка, действителен ли этот токен до сих пор, и сохранена ли безопасность данных. В дальнейшем, данный токен 
должен быть прописан перед всеми POST-методами. Чтобы добавить переданный параметром obj в базу данных получаем 
доступ к DbContext в виде _db.ИмяМодели, далее обращаемся к методу .Add() из Entity Framework Core, и в скобки
передаем наш объект. После этой строки пишем _db.SaveChanges(). Теперь произошла передача и сохранение новой 
информации в базе данных.
	
	--- Чтобы использовать валиацию, в .NET Core существует библиотека аннотации данных 
System.ComponentModel.DataAnnotations. Она использует аттрибуты типа [Key], [Requiered] и тд. Аттрибуты валидации
прописываются перед нужный свойством в модели. Валидация может проводиться как на стороне сервера, так и на стороне
клиента. На стороне сервера валиадиация может проходить с помощью аттрибутов валидации, тэг-хэлперов 
asp-validation-summary, asp-validation-for, с помощью метода ModelState.IsValid(). Чтобы сделать валидацию на 
стороне клиента, в самом конце нужной модели пишем @section Scripts {}. Нам же нужно добавить скриптовый файл 
Views -> Shared -> _ValidationScriptsPartial.cshtml в эту секцию. Данный скрипт автоматически выполнит 
проверку данных на стороне клиента. Чтобы его добавить, пишем @{ <partial name="_ValidationScriptsPartial" /> }.
Теперь, при вводе неправильных данных, эти данные не отправляются на сервер, они проверяются еще на стороне клиента.
	--- Чтобы изменить информацию из таблицы базы данных, необходимо указывать Id ячейки, которую мы 
собираемся изменить. Делается это с помощью тэг-хэлпера asp-route-Id="@obj.Id". В контроллере создаем
get-метод для редактирования, после названия метода в скобках указываем Id, переданный сюда из тэг-хэлпера 
asp-route-Id. Получив этот Id, нужно далее получить информацию об этой сущности с данным Id. Нужно вывести ее на 
экран. Для начала проверяем, есть ли значение в этом Id - не равен ли он 0, поэтому после типа параметра пишем ?, 
чтобы дать возможность передавать в метод значения null в качестве параметра. Также можно добавить проверку, равен
ли Id нулю, в таком случае возвращаем объект return NotFound(). В противном же случае мы хотим получить объект
из базы данных, для этого пишем var obj = _db.ИмяМодели.Find(id) и в конце возвращаем полученный объект в return
View(obj). Далее необходимо заняться POST-методом, для отправки на сервер измененной информации на сайте. Копируем
тело метода GET для Create и только изменяем метод Add на Update. Пост метод готов. Однако если передаваемый объект
будет сложным, который состоит из других объектов, в методе возникнет ошибка, так как Id не используется, он будет
неопределенным. Чтобы этого избежать, в самом начале формы добавляем <input asp-for="Id" hidden />. Теперь, когда 
в ПОСТ запросе будет использована эта форма, в объекте будет использовать уже и Id. Метод Update() будет корректно
работать только если есть ссылка на Id, так как на основании его будет производиться поиск сущности с таким Id, и
тогда выполнится обновление базы данных.
	--- При удалении ячейки с Id, схема будет похожая, только поля для ввода должны быть неизменяемыми. В скобках 
GET и POST методов нам не нужна полная информация об объекте, нужен только Id, причем int? (допускается значение
null). Однако дав одинаковый параметр двум одинаковым методам, мы получаем ошибку. Чтобы ее избежать, меняем 
название, например POST-метода на DeletePost (во View нужно все равно использовать название Delete). В POST-методе
вместо метода Update используем метод Remove, в скобках уже указываем не весь объект, а только его Id, который
можно получить благодаря строке var obj = _db.ИмяМодели.Find(id). Id мы передали в качестве параметра. С помощью
метода _db.SaveChanges() сохраняем базу данных и перенаправляем исполнение кода обратно в action-метод Index 
с помощью строки return RedirectToAction("Index"). В POST-методе удаления не нужна валидация, необходима лишь
проверка, определен ли этот объект, проверяем это с помощью if (obj == null) {}. В теле возрващаем объект 
return NotFound(). Если же объект определен, мы можем его удалить, и перенаправиться обратно на Index. Во View, 
удаляем всю валидацию и, чтобы сделать поля для ввода неизменяемыми, в атрибуты пишем disabled. Однако, если на 
этом этапе запустить приложение и нажать кнопку Delete, ничего не произойдет, потому что в контроллере название
POST-метода не Delete, а DeletePost. Чтобы исправить ошибку, переходим во View для Delete и в атриутах формы пишем 
asp-action="DeletePost" - это один из способов решения проблемы: если название action-метода не совпадает 
с названием View, можно явно через тэг-хэлпер asp-action указать, какой метод нужно вызвать для POST-запроса
в данной форме.
	
	--- СЕКЦИЯ 4


